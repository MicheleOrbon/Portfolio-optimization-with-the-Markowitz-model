# -*- coding: utf-8 -*-
"""Portfolio optimization with the Markowitz model

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1N58OrUCTDZ0YalV4aaGJ0pl5bJjTa5sy
"""

# 0 NECESSARY IMPORT

#necessary to install yfinance numpy pandas matplotlib scipy to run the programm correctly
import yfinance as yf
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from scipy.optimize import minimize
from datetime import datetime, date

# 1 USER INPUT

user_input = input("Enter the tickers separated by commas (example: AAPL, MSFT, AMZN, GOOGL, KO, JNJ, XOM, JPM, TSLA, DIS): ")
tickers = [t.strip().upper() for t in user_input.split(',') if t.strip()]
while True:
    start_input = input("Enter the start date (YYYY-MM-DD), e.g. 2018-01-01: ").strip()
    try:
        start_date = datetime.strptime(start_input, "%Y-%m-%d").date()
        break
    except ValueError:
        print("Invalid format. Please use YYYY-MM-DD (for example: 2018-01-01).")
end_date = datetime.today()
print(f"Downloading data for {tickers} from {start_date} to {end_date} ...")

df_raw = yf.download(tickers, start=start_date, end=end_date, auto_adjust=False, group_by="ticker")

# 2 NORMALIZE DOWNLOADED DATA

# Extract 'Adj Close' prices (or fallback to 'Close') -> columns = tickers
if isinstance(df_raw.columns, pd.MultiIndex):
    # level 0 = ticker, level 1 = field name
    try:
        df = df_raw.xs('Adj Close', axis=1, level=1, drop_level=True)
    except KeyError:
        df = df_raw.xs('Close', axis=1, level=1, drop_level=True)
else:
    # single ticker: flat columns with field names
    col = 'Adj Close' if 'Adj Close' in df_raw.columns else 'Close'
    df = df_raw[[col]].copy()
    # rename the column to match the selected ticker
    df.columns = [tickers[0]]

# Remove any columns that are completely empty
df = df.dropna(axis=1, how='all')
if df.empty:
    raise ValueError("Downloaded data is empty. Please check the tickers and date range.")

# 3 OPTIONAL DATA PREVIEW

choice = input("Do you want to see the downloaded prices? (yes/no): ").strip().lower()

if choice in ['s', 'si', 's√¨', 'yes', 'y']:
  nrows_input = input("How many days do you want to display? ")
  try:
    # Try converting input to integer
    nrows = int(nrows_input)
    print(f"Here are the last {nrows} days of downloaded prices:")
    print(df.tail(nrows))
  except ValueError:
    # If input is not an integer, show last 10 days by default
    print("Invalid input. Showing the last 10 days by default:")
    print(df.tail(10))
else:
    print("Proceeding without displaying data.")

# 4 RETURNS AND COVARIANCE MATRIX

rets = df.pct_change().dropna()
mean_returns = (rets.mean() * 252).to_numpy()               # shape (n,)
cov_matrix = (rets.cov() * 252).to_numpy()                  # shape (n,n)
cov_matrix = cov_matrix + np.eye(len(mean_returns)) * 1e-8
# small regularization term for numerical stability
n = len(mean_returns)
bounds = tuple((0.0, 1.0) for _ in range(n))
x0 = np.repeat(1/n, n)

# 5 SUPPORT FUNCTIONS

def portfolio_perf(w, mu, cov):
    """Calculate portfolio volatility (std) and expected return."""
    std = np.sqrt(w @ cov @ w)
    ret = w @ mu
    return std, ret

def minimize_volatility(mu, cov, target_return):
    """Minimize portfolio volatility for a given target return."""
    constraints = (
        {'type': 'eq', 'fun': lambda w: np.sum(w) - 1.0},     # sum of weights = 1
        {'type': 'eq', 'fun': lambda w: w @ mu - target_return}
    )
    result = minimize(lambda w: portfolio_perf(w, mu, cov)[0],
                      x0, method='SLSQP', bounds=bounds, constraints=constraints)
    return result

# 6 EFFICIENT FRONTIER

# For long-only portfolios, returns range between min(mu) and max(mu)
mu_min, mu_max = float(np.min(mean_returns)), float(np.max(mean_returns))
target_returns = np.linspace(mu_min + 1e-6, mu_max - 1e-6, 60)

frontier_vol, frontier_ret = [], []
for tr in target_returns:
    res = minimize_volatility(mean_returns, cov_matrix, tr)
    if res.success:
        frontier_vol.append(res.fun)       # minimum volatility for this target return
        frontier_ret.append(tr)


# 7 PORTFOGIO MIN-VAR

res_mvp = minimize(lambda w: (w @ cov_matrix @ w)**0.5,
                   x0, method='SLSQP', bounds=bounds,
                   constraints=({'type': 'eq', 'fun': lambda w: np.sum(w)-1}))
w_mvp = res_mvp.x
std_mvp, ret_mvp = portfolio_perf(w_mvp, mean_returns, cov_matrix)

# 8 OPTIMAL PORTFOLIO (MAX SHARPE RATIO)

risk_free = 0.02  # assumed risk-free rate (2%)

def neg_sharpe_ratio(w, mu, cov, rf):
    std, ret = portfolio_perf(w, mu, cov)
    return -(ret - rf) / std  # negative for minimization

constraints = ({'type': 'eq', 'fun': lambda w: np.sum(w) - 1})
bounds = tuple((0.0, 1.0) for _ in range(n))

opt_result = minimize(neg_sharpe_ratio, x0, args=(mean_returns, cov_matrix, risk_free),
                      method='SLSQP', bounds=bounds, constraints=constraints)

opt_weights = opt_result.x
opt_std, opt_ret = portfolio_perf(opt_weights, mean_returns, cov_matrix)
opt_sharpe = (opt_ret - risk_free) / opt_std

print("\n Min Variance Portfolio")
for t, w in zip(tickers, w_mvp):
    print(f"{t}: {w:.2%}")
print(f"Expected Return: {ret_mvp:.2%}")
print(f"Volatility: {std_mvp:.2%}")

print("\n Optimal Portfolio (Maximum Sharpe Ratio)")
for t, w in zip(tickers, opt_weights):
    print(f"{t}: {w:.2%}")
print(f"Expected Return: {opt_ret:.2%}")
print(f"Volatility: {opt_std:.2%}")
print(f"Sharpe Ratio: {opt_sharpe:.2f}")

# Add point on the frontier
plt.figure(figsize=(9, 6))
plt.plot(frontier_vol, frontier_ret, '--', label='Efficient Frontier')
plt.scatter(opt_std, opt_ret, color='red', marker='*', s=160, label='Optimal Portfolio')
plt.scatter(std_mvp, ret_mvp, marker='o', color='red', s=90, label='Min-Var')
plt.xlabel('Risk (Volatility)')
plt.ylabel('Expected Return')
plt.title('Efficient Frontier with Optimal Portfolio')
plt.legend()
plt.grid(True)
plt.show()

# 9 Conclusion
print("""
Conclusions:
The optimal portfolio was determined using the Markowitz model,
maximizing the Sharpe Ratio with a 2% risk-free rate.

Key observations:
- The portfolio achieves a balance between high return and controlled risk.
- Assets with stronger historical returns and lower correlation received higher weights.
- The efficient frontier shows that diversification significantly reduces volatility.
- Investors with higher risk tolerance could move toward portfolios on the upper part of the curve.
""")
