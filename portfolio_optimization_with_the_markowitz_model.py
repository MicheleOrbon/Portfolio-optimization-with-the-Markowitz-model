# -*- coding: utf-8 -*-
"""Portfolio optimization with the Markowitz model

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1N58OrUCTDZ0YalV4aaGJ0pl5bJjTa5sy
"""

# 0 NECESSARY IMPORT

# necessary to install yfinance numpy pandas matplotlib scipy to run the programm

import yfinance as yf
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from scipy.optimize import minimize
import datetime
from pickle import TRUE

# 1 USER INPUT

user_input = input("Enter the tickers separated by commas (available: AAPL, MSFT, AMZN, GOOGL, KO, JNJ, XOM, JPM, TSLA, DIS): ")
tickers = [t.strip().upper() for t in user_input.split(',') if t.strip()]
while True:
    start_input = input("Enter the start date (YYYY-MM-DD), e.g. 2018-01-01: ").strip()
    try:
        start_date = datetime.datetime.strptime(start_input, "%Y-%m-%d").date()
        break
    except ValueError:
        print("Invalid format. Please use YYYY-MM-DD (for example: 2018-01-01).")
end_date = datetime.date.today()
print(f"Downloading data for {tickers} from {start_date} to {end_date} ...")
df = yf.download(tickers, start=start_date, end=end_date, auto_adjust=False)


# 2 NORMALIZE DOWNLOADED DATA

# Check whether the data is a Series (single ticker) or a DataFrame (multiple tickers)
if isinstance(df, pd.Series):
    # If it's a Series, it’s likely the ‘Adj Close’ for a single ticker
    df = df.to_frame()
    df.columns = [tickers[0]]  # Rename the column with the ticker symbol
elif 'Adj Close' in df.columns:
    # If it's a DataFrame and has ‘Adj Close’, select it
    df = df['Adj Close']
else:
    # Handle other cases or warn if ‘Adj Close’ is not found
    print(" Warning: 'Adj Close' not found in the downloaded data.")

# 3 OPTIONAL DATA PREVIEW

choice = input("Do you want to see the downloaded prices? (yes/no): ").strip().lower()

if choice in ['s', 'si', 'sì', 'yes', 'y']:
  nrows_input = input("How many days do you want to display? ")
  try:
    # Try converting input to integer
    nrows = int(nrows_input)
    print(f"Here are the last {nrows} days of downloaded prices:")
    print(df.tail(nrows))
  except ValueError:
    # If input is not an integer, show last 10 days by default
    print("Invalid input. Showing the last 10 days by default:")
    print(df.tail(10))
else:
    print("Proceeding without displaying data.")

# 4 RETURNS AND COVARIANCE MATRIX

rets = df.pct_change().dropna()
mean_returns = (rets.mean() * 252).to_numpy()               # shape (n,)
cov_matrix = (rets.cov() * 252).to_numpy()                  # shape (n,n)
n = len(mean_returns)
bounds = tuple((0.0, 1.0) for _ in range(n))
x0 = np.repeat(1/n, n)

# 5 SUPPORT FUNCTIONS

def portfolio_perf(w, mu, cov):
    """Calculate portfolio volatility (std) and expected return."""
    std = np.sqrt(w @ cov @ w)
    ret = w @ mu
    return std, ret

def minimize_volatility(mu, cov, target_return):
    """Minimize portfolio volatility for a given target return."""
    constraints = (
        {'type': 'eq', 'fun': lambda w: np.sum(w) - 1.0},     # sum of weights = 1
        {'type': 'eq', 'fun': lambda w: w @ mu - target_return}
    )
    result = minimize(lambda w: portfolio_perf(w, mu, cov)[0],
                      x0, method='SLSQP', bounds=bounds, constraints=constraints)
    return result

# 6 EFFICIENT FRONTIER

# For long-only portfolios, returns range between min(mu) and max(mu)
mu_min, mu_max = float(np.min(mean_returns)), float(np.max(mean_returns))
target_returns = np.linspace(mu_min + 1e-6, mu_max - 1e-6, 60)

frontier_vol, frontier_ret = [], []
for tr in target_returns:
    res = minimize_volatility(mean_returns, cov_matrix, tr)
    if res.success:
        frontier_vol.append(res.fun)       # minimum volatility for this target return
        frontier_ret.append(tr)

plt.figure(figsize=(8, 6))
plt.plot(frontier_vol, frontier_ret, '--', label='Efficient Frontier')
plt.xlabel('Risk (Volatility)')
plt.ylabel('Expected Return')
plt.title('Efficient Frontier (Markowitz Model)')
plt.legend()
plt.grid(True)
plt.show()

# 7 OPTIMAL PORTFOLIO (MAX SHARPE RATIO)

risk_free = 0.02  # assumed risk-free rate (2%)

def neg_sharpe_ratio(w, mu, cov, rf):
    std, ret = portfolio_perf(w, mu, cov)
    return -(ret - rf) / std  # negative for minimization

constraints = ({'type': 'eq', 'fun': lambda w: np.sum(w) - 1})
bounds = tuple((0.0, 1.0) for _ in range(n))

opt_result = minimize(neg_sharpe_ratio, x0, args=(mean_returns, cov_matrix, risk_free),
                      method='SLSQP', bounds=bounds, constraints=constraints)

opt_weights = opt_result.x
opt_std, opt_ret = portfolio_perf(opt_weights, mean_returns, cov_matrix)
opt_sharpe = (opt_ret - risk_free) / opt_std

print("Optimal Portfolio (Maximum Sharpe Ratio)")
for t, w in zip(tickers, opt_weights):
    print(f"{t}: {w:.2%}")
print(f"Expected Return: {opt_ret:.2%}")
print(f"Volatility: {opt_std:.2%}")
print(f"Sharpe Ratio: {opt_sharpe:.2f}")

# Add point on the frontier
plt.figure(figsize=(8, 6))
plt.plot(frontier_vol, frontier_ret, '--', label='Efficient Frontier')
plt.scatter(opt_std, opt_ret, color='red', marker='*', s=150, label='Optimal Portfolio')
plt.xlabel('Risk (Volatility)')
plt.ylabel('Expected Return')
plt.title('Efficient Frontier with Optimal Portfolio')
plt.legend()
plt.grid(True)
plt.show()

# 8 Conclusion
print("""
Conclusions:
The optimal portfolio was determined using the Markowitz model,
maximizing the Sharpe Ratio with a 2% risk-free rate.

Key observations:
- The portfolio achieves a balance between high return and controlled risk.
- Assets with stronger historical returns and lower correlation received higher weights.
- The efficient frontier shows that diversification significantly reduces volatility.
- Investors with higher risk tolerance could move toward portfolios on the upper part of the curve.
""")
